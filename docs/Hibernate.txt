Draw Backs of JDBC:

> In JDBC, Programmer has to take care of DB Connection - creation, exception handling and closure.
> If Programmer didn’t close the connection in the finally block, then JDBC is not responsible to close that connection.
> If the table structure is modified then the JDBC program (original SQL Commands) doesn’t work.  Again we need to modify and compile and re-deploy required, which is tedious.
> JDBC generates database related error codes when exceptions are encountered; Java programmers are unaware of these error codes.
> In the Enterprise applications, the data flow with in an application from class to class will be in the form of objects, but while storing data finally in a database using JDBC then that object will be converted into text.  Because JDBC doesn’t transfer objects directly.

In order to overcome above problems,  Hibernate came into picture!

--------------------------
What is Hibernate?
Hibernate is the ORM tool given to transfer the data between a java (object) application and a database (Relational) in the form of the objects.  

It was started in 2001 by Gavin King as an alternative to EJB2 style entity bean.

Hibernate is a non-invasive framework meaning it won't force the programmers to extend/implement any class/interface. Because of use of POJO classes, Hibernate is light weight. It is purely for persistence (to store/retrieve data from Database).

The term Object/Relational Mapping refers to the technique of mapping data from an object model representation to a relational data model representation (and visa versa).

Hibernate not only takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types), but also provides data query and retrieval facilities. It can significantly reduce development time otherwise spent with manual data handling in SQL and JDBC. Hibernate’s design goal is to relieve the developer from 95% of common data persistence-related programming tasks by eliminating the need for manual, hand-crafted data processing using SQL and JDBC. However, unlike many other persistence solutions, Hibernate does not hide the power of SQL from you and guarantees that your investment in relational technology and knowledge is as valid as always.

Hibernate may not be the best solution for data-centric applications that only use stored-procedures to implement the business logic in the database, it is most useful with object-oriented domain models and business logic in the Java-based middle-tier. 

--------------------------
Requirements:

Hibernate 5.2 and later versions require at least Java 1.8 and JDBC 4.2.

Hibernate 5.1 and older versions require at least Java 1.6 and JDBC 4.0.

--------------------------
Features/advantages of Hibernate:
JPA Provider - In addition to its own "native" API, Hibernate is also an implementation of the Java Persistence API (JPA) specification. As such, it can be easily used in any environment supporting JPA including Java SE applications, Java EE application servers, Enterprise OSGi containers, etc.

Idiomatic persistence - Hibernate enables you to develop persistent classes following natural Object-oriented idioms including inheritance, polymorphism, association, composition, and the Java collections framework. Hibernate requires no interfaces or base classes for persistent classes and enables any class or data structure to be persistent.

Support Performance - Hibernate supports lazy initialization, numerous fetching strategies and optimistic locking with automatic versioning and time stamping. Hibernate requires no special database tables or fields and generates much of the SQL at system initialization time instead of at runtime. Hibernate consistently offers superior performance over straight JDBC code, both in terms of developer productivity and runtime performance.

Scalable - Hibernate was designed to work in an application server cluster and deliver a highly scalable architecture. Hibernate scales well in any environment: Use it to drive your in-house Intranet that serves hundreds of users or for mission-critical applications that serve hundreds of thousands.

Reliable - Hibernate is well known for its excellent stability and quality, proven by the acceptance and use by tens of thousands of Java developers.

Extensibile - Hibernate is highly configurable and extensible

--------------------------
Persisting data to DB without hibernate:
	1. JDBC DB config - hostname, port, credentials etc.
	2. Define Model object to be stored.
	3. Service method to create/instantiate Model Object.
	4. Database Design for data storage.
	5. DAO method to save object using SQL query.
--------------------------
Persisting data to DB with hibernate:
	1. JDBC DB config - hibernate configuration (hibernate.cfg.xml)
	2. Define Model object to be stored - @Entity annotated class.
	3. Service method to create/instantiate Model Object - use Hibernate API
	Database Design for data storage - optional or not required (hibernate.hbm2ddl.auto property of hibernate configuration can take care of it).
	DAO method to save object using SQL query - not needed.
--------------------------
Service method to create/instantiate Model Object - use Hibernate API
	1. Create a "session factory" (one per app as is costlier operation - this step should use the default config file i.e. hibernate.cfg.xml file.): 
		SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
	2. Create a "session" from "session factory": 
		Session session = sessionFactory.openSession();
	3. Save model object using session:
		session.beginTransaction();
		session.save(userObject);
		session.getTransaction().commit();
		session.close();
	4. Create another session for a different opertation Ex. UserDetails userObject2 = (UserDetails)session.get(UserDetails.Class, 11186) and close it.
	5. Close sessionFactory.
* Create Session Factory - based on cfg file. Only one obj per appl.
* Create Session - from Session Factory.
* Use Session to save model obj.
--------------------------
Annotations:
@Entity annotate bean or pojo class. property name of the same can be used for the respective table name in DB. Resevered Keywords like user is not allowed for DB table name.

@Table annotate the pojo class to map to a table. property name of the same can be used to name the DB table. It won't change the default (class name) entity name (will be used in HQL query).

@Id & @Column annotations can be used with individual data members of the POJO class or with the getters to the same. Value to be stored in DB will be picked up using getter methods.

@Id => Primary Key.
Surrogate Key -> When a table is not having a column to be marked as primary key, Sr No key column (for example) can be added for making it as primary key.

Hibernate can generate value for Primary (Surrogate) Key using @GeneratedValue annotation along with @Id.

@GeneratedValue has property "strategy" with possible values of GenerationType enumeration - AUTO, IDENTITY (not with all DB), SEQUENCE (uses DB Sequence object), TABLE. Default is AUTO. Ex. @GeneratedValue (strategy=GenerationType.AUTO)

Hibernate maps java data types to db data types.
	String -> varchar(255)
	Int -> int
	Date -> date or timestamp
	
@Basic annotation for a data member tells hibernate that consider it as a data to be persisted. Default behavior is also the same.

@Transient annotation implies that the respective data member will be ignored for data persistence to DB. Static fields are also ignored.

@Temporal annotation is used to take a part of the date data type. It has property TemporalType enumeration to choose value from like TemporalType.DATE, TemporalType.TIME etc.

What if varchar(255) is not sufficient to store a column value?
use @Lob annotation. Maps to BLOB or CLOB data types depending on data contents.
--------------------------
What if a data member is an Object itself. Ex. Address of UserDetails class?
Address is "value object" inside UserDetails "Entity".

Approach 1: to have separate columns for address object members. Mark Address as @Embeddable to make it an object of Value type or use @Embedded annotation with Address member variable on UserDetails class.

However, 1 problem to address - what if 2 address data members are there - homeAddress & officeAddress. The corresponding insert will have duplicate name columns.
=> use @AttributeOverride annotation. properties name & column can be used to override column names of Address data memebers.
Ex.
@AttributeOverrides({
@AttributeOverride(name="street", column=@Column(name="home_street")),
@AttributeOverride(name="city", column=@Column(name="home_city")),
.
.
})
private Address homeAddress;

Approach 2: 

**************************
Which java features have you used in your application

> Core Java coding - interfaces, beans, utils, dao layers; String functions, StringBuffer/Builder, POJOs, Date functions, Exception Handling, Static Functions like isNull, isNumeric etc., Generics, Collection APIs (like HashMap, ArrayList etc.)
> File I/O - for properties or config, writing contents to excel or pdf other files.
> Log4J Logging
> Apache APIs - for String functions (StringUtils), Validating email address (EmailValidator),POI API (XSSFWorkbook) for excel file generation.
> JDBC APIs - Read Config from DB, Run procs through callable statements & get results, run report queries & process them etc.
> javax.crypto.Cipher API for pwd encryption
> Servlets - for realizing app functions (ex. generating PDF file; loading meta data)
> JSPs, JSPFs etc. (& related tag libraries, display tage lib & decorator classes) for view logic for Struts 1 & Struts 2 framework
> JNDI lookup for App Server resources - data sources, jms queues etc.
> JMS for loading meta data -> Uses Topic destination object for JMS communication.
	- Lookup TopicConnectionFactory & use it to lookup further the javax.jms.Topic.
	- Send Message every time meta data is updated i.e. publish message [TopicConnection > TopicSession > TopicPublisher (using createTextMessage method of TopicSession and publish method of TopicPublisher)]
	- Use TopicConnectionFactory to get TopicConnection and use it to set up Message Listener [TopicConnection > TopicSession > TopicSubscriber (setMessageListener method passing class name which is implementing javax.jms.MessageListener)].

--------------------------------------
JSPF means?
JSP Fragments can be compared to server side includes. These fragments are not compiled on their own, however there are compiled along side the page in which its included. JSPF files can be thought of as a first step in refactoring large JSP pages.
--------------------------------------

Callable Statement use in PDTS?

1. Prepare a Call to a Stored Proc & Execute it.
2. Can set params to be passed to the proc.
3. Can register out param (of varchar or cursor type) - Can retrieve cursor as resultset & process it.
4. Cursor type needs to be defined in SPEC of package - like "TYPE followUp_cursor IS REF CURSOR;"

Using REF CURSOR s is one of the most powerful, flexible, and scalable ways to return query results from an Oracle Database to a client application. A REF CURSOR is a PL/SQL data type whose value is the memory address of a query work area on the database. In essence, a REF CURSOR is a pointer or a handle to a result set on the database.

A REF CURSOR involves an additional database round-trip. While the REF CURSOR is returned to the client, the actual data is not returned until the client opens the REF CURSOR and requests the data. Note that data is not be retrieved until the user attempts to read it.

A REF CURSOR is not updatable. The result set represented by the REF CURSOR is read-only. You cannot update the database by using a REF CURSOR.

A REF CURSOR is not backward scrollable. The data represented by the REF CURSOR is accessed in a forward-only, serial manner. You cannot position a record pointer inside the REF CURSOR to point to random records in the result set.

A REF CURSOR refers to a memory address on the database. Therefore, the client must be connected to the database during the lifetime of the REF CURSOR in order to access it.

-------------------------------------
Any perf tuning work done

In the current project - none as the applications were not expecting any performance issues except for the query tuning at some places. That were taken care by the DBA team. I was just involved to take care of a memory leak when DBA highlighted some long open app user sessions. 

There was a performance test team in my earlier assignment. They used to stress test the app for any performance issues. And we were handling them if any. As a part of that only, I migrated one soap based web app to axis 2 web service based web app.

Otherwise, I was just following some of the standards that were set to avoid performance issues.

Define or follow Guidelines:
 - Set a goal: like maximum concurrent users the application will support for a given limit on response times; the response times should not increase more than 10 percent during the peak hour of user load.
 
 - Identify problem areas: A little investigation into problems might reveal the specific component that causes poor performance. For example, if the CPU usage on an application server is high, you will want to focus on tuning the application server first.
 
 - Follow a methodical and focused path: try to make changes that are expected to have the biggest impact on performance. Your time is better spent tuning a method that takes 10 seconds but gets called 100 times than tuning a method that takes one minute but gets called only once. 

Stress tools - Many different stress tools are available in the market today.
Performance monitors - Using a monitoring tool, you collect data for various system performance indicators for all the appropriate nodes in your network topology. Many stress tools also provide monitoring tools.

Environment tuning: 
 - A J2EE application environment usually consists of an application server, Web server, and a backend database.
 - Web/App Server: most important setting for your Windows Apache HTTP Server is the option for number of threads. This value should be high enough to handle the maximum number of concurrent users, but not so high that it starts adding its own overhead of too many context switches. The optimum value can be determined by monitoring the number of threads in use during peak hours. The JVM performs best with the fewest busy threads. A good starting point for threadcount can be found with the following equations.
	(Number of Java Execution Threads) = Number of Transactions / Time(in seconds)
	or
	(Number of Execution Threads)=Throughput(transactions/sec)
 Other tuning options: Do not load unnecessary modules; Try to minimize logging as much as possible; Use the latest Java version.
 Heap Size: Keep its value optimum. If you still run out of memory, look into your application design to reduce memory usage, identify any memory leaks, or try various garbage collector options in the JVM.
 - Database Tuning: 
	- Run DB Server on dedicated instead of shared machine. 
	- Keep your application database and your temporary database on different hard disks. 
	- Consider taking local backups and moving them to a different machine. The backups should complete much faster. 
	- Normalize your database to the third normal form. This is usually the best compromise, as the fourth and fifth forms of normalization can result in performance degradation.
 - Application Tuning: 
	- Explicitly assigning a null value to variables that are no longer needed helps the garbage collector to easily identify the parts of memory that can be safely reclaimed. While Java automates memory management, it does not prevent usage of excessive amounts of memory or memory leaks.
	- Do not synchronize code blocks or methods unless synchronization is required. Keep synchronized blocks or methods as short as possible to avoid scalability bottlenecks.
	- Only declare methods as final when absolutely necessary: Modern optimizing dynamic compilers can perform inlining and other inter-procedural optimizations, even if Java methods are not final. If you are absolutely certain that a method must not be overridden, use the final keyword.
	- Declare constants as static final: The dynamic compiler can perform some constant folding optimizations easily, when the hint is provided.
	- Avoid finalizers: Adding finalizers to your code makes the garbage collector more expensive and unpredictable. Finalizers may not always be executed, before the program exits. Releasing critical resources in finalize() methods may lead to unpredictable application behavior.
	- Declare method arguments final if they are not modified in the method. 
	- Use a logging mechanism (like log4j) that lets you switch off logging in the production environment to reduce logging overhead.
	- Instead of creating and destroying resources every time you need them, use a resource pool for every resource (ex. JDBC Connection, Thread) that is costly to create. The number of database connections, commonly known as a connection or resource pool, is closely tied to the number of execution threads. A rule of thumb is to match the number of database connections to the number of execute threads. Over-configuring this value could cause unnecessary overhead to the database, while under-configuring could tie up all execution threads waitingon database I/O.
	- Try to minimize the objects you store in HttpSession. Extra objects in HttpSession not only lead to more memory usage, they also add additional overhead for serialization/deserialization in case of persistent sessions.
	- Where ever possible, use RequestDispatcher.forward() instead of HttpServletResponse.sendRedirect(), as the latter involves a trip to the browser.
	- Minimize the use of SingleThreadModel in servlets so that the servlet container does not have to create many instances of your servlet.
	- Java stream objects perform better than reader/writer objects because they do not have to deal with string conversion to bytes. Use OutputStream in place of PrintWriter.
	- Reduce the default session timeout either by changing your servlet container configuration or by calling HttpSession.setMaxInactiveInterval() in your code.
	- Always add directive <%@ page session="false"%> to JSP pages where you do not need a session.
	- Use the jspInit() method to cache static data, and release them in the jspDestroy() method.
	- Use StringBuffer rather than using + operator when you concatenate multiple strings.
	- Excessive use of custom tags also may result in poor performance. Keep performance in mind while designing your custom tag library.
	- In Java, serialization and deserialization of objects is a CPU-intensive procedure and is likely to slow down your application. Use the transient keyword to reduce the amount of data serialized. Customized readObject() and writeObject() methods may be beneficial, in some cases.
	- Serialization uses reflection extensively, and this also makes it slow.
	- The Externalizable interface is provided to solve Serialization's performance problems. Make classes Externalizable on a case-by-case basis to improve performance.
	- Start the consumer before you start the producer so that the initial messages do not need to queue.
	- Close resources (e.g. connections, session objects, producers, consumers) when finished with them.
	- Choose non-durable (NON_PERSISTENT) messages wherever appropriate to avoid the persistency overhead.
	- Tune the Destination parameters: a smaller capacity increases message throughput; a higher redelivery delay and lower redelivery limit reduces the overhead.
	- Set the TimeToLive value as low as feasible (default is for messages to never expire).
	- Receive messages asynchronously with a MessageListener implementation. 
	- Use the servlet init() method to cache static data, and release them in the destroy() method.
	- Use StringBuffer rather than using + operator when you concatenate multiple strings.
	- Use the print() method rather than the println() method.
	- Use a ServletOutputStream rather than a PrintWriter to send binary data.
	- Use the application server's caching facility.
	- Session mechanisms from fastest to slowest are: HttpSession, Hidden fields, Cookies, URL rewriting, the persistency mechanism.
	- Set the session time-out value as low as possible.
	- Reduce the number of remote calls made by an application to improve performance.
	- Cache remote objects locally where possible, rather than repeatedly fetching them.	
 - SQL query optimization
	- Keep the transactions as short as possible. The longer a transaction is open, the longer it holds the locks on the resources acquired, and every other transaction must wait.
	- Do not use DISTINCT clauses unnecessarily (i.e. when you know the rows will be unique). 
	- When possible, avoid using SELECT *.
	- Consider adding indexes to those columns causing full-table scans for your queries.
	- Avoid using too many string functions (like SUBSTRING, LOWER, UPPER, and LIKE) or operators in your queries.
	- Group all related search queries in a single JDBC call. The basic idea of performance tuning in DAO layer is to reduce the number of JDBC calls.
	- Whenever your select query involves more than 6 tables, try to denormalize the table. To improve the performance, you need to reduce the number of tables. 
	- In case of batch operations, it is not a good idea to create SQL queries. SQL query will be compiled every time and then it is executed. You can use stored procedures. Stored procedures are compiled only once when they are executed for the first time.
	- Avoid using views unless it is really needed. Querying from view takes more time than directly querying from the table.
	- Try to use prepared statements as they are precompiled.
	 
Performance tuning is an ongoing process. Simply put, good system performance depends on good design, good implementation, defined performance objectives and performance tuning. Mechanisms have to be implemented that provide performance metrics which can be compared against the performance objectives defined.

-------------------------------------
What does that you do on day-to-day activity?
1. Development:
	- Coding in core java, using JDBC API, struts1 - struts2 based code update. JSPs update, Servlet updates etc.
	- Test cases writing.
	- Build code using Maven, Deploy code to WebLogic Server using Jenkins. DevOps.
	- Spring Boot, Hibernate, MicroServices based code update.
	- AngularJS for UI code. HTML5, CSS & Bootstrap.
	- Writing sql queries, updating pl-sql procedures, packages & functions etc.
	- Shell scripts - cron job script updates on App Script Server.
	- Delivery in Agile sprints.
2. Unit Test:
	- Running test cases with Maven, Jenkins.
	- Increase test coverage for existing code - struts 1 (StrutsTestCase API); struts 2 (XworkTestCase API).	
	- Manual testing and test results generation.	
3. Others:
	- Estimation
	- CFM using SVN (with tool SmartSVN).
	- Doing POCs (Proof of concepts) for different proposals using client recommended Open-Source technologies.
	- Reporting activities - report progress of team on different assignments (POCs and Project work).
-------------------------------------
Spring & Hibernate experience
I am using Spring Boot for the POC work. It's based on MicroServices architecture.
Hibernate I have used in the past project.
-------------------------------------
What part of java you like most
Spring Boot based app development has been the best thing that i had done till date. 

I like to work on value adds that can be useful to others. Not specific to any technologies, I had done few VAs related to POCs, Build process, Test Automation, Continuous Integration and Automated Deployment using Jenkins, LoginAs Function, Log Rotation tool, Email framework.

Technologies used were - Spring Boot, AngularJS, Unix Shell Scripts, Jenkins, Maven, Struts 2 framework, Java/J2EE.
-------------------------------------
What did you do as Solution Architect
It was rather an Applicaiton Architect role.

As a Solution Architect, I was responsible to determine and propose solutions to the business problems based on the domain and app knowledge. For instance, for SRS reporting app, there was a new metrics data that Client was looking to make available on SRS UI. The high level steps involved were:
- Extracting the data from the source app.
- Making it available to SRS app to consume.
- Report on the consumed data.

My reponsibility was to define processes, practices & rules of how these activities would be done by each of the interacing apps with more focus on SRS app more.

For instance above 3 activities were proposed to be done in the following way.
1. Data extraction - source app was free to choose way of. However the mode of file transfer was CSV files over SFTP (as the Company std was use of SFTP vs FTP).
2. Data cosumption - SRS was already having a mechanism to process csv or flat files and store data to SRS DB. Asked them to either reuse existing mechanism or develop new as necessary.
3. Data Reporting - SRS had a custom report framework with which dynamic reports could be generated.
-------------------------------------
How to take thread dump and why is it needed?
What is thread dump?
A thread dump is a snapshot of the state of all threads that are part of the process. The state of each thread is presented with a so called stack trace, which shows the contents of a thread’s stack. Some of the threads belong to the Java application you are running, while others are JVM internal threads.

A thread dump reveals information about an application’s thread activity that can help you diagnose problems and better optimize application and JVM performance; for example, thread dumps automatically show the occurrence of a deadlock. Deadlocks bring some or all of an application to a complete halt.

Why to take thread dump?
Main use - for troubleshooting and diagnostics. Analyse dumps with other diagnostics tools, such as the JRockit Runtime Analyzer, which is part of Oracle JRockit Mission Control.
1. Detecting Deadlocks - The Oracle JRockit JVM automatically analyzes the thread dump information and detects whether there exists any circular (deadlocked) or blocked lock chains in it.
2. Detecting Processing Bottlenecks - If you discover (in a set of consecutive thread dumps) that one or more threads in your application is temporarily stuck waiting for a lock to be released, then you might have reason to look over the code of your Java application to see if the synchronization (serialization) is necessary or if the threads can be organized differently.
3. Viewing The Runtime Profile of an Application - By making several consecutive thread dumps, you might quickly get an overview of which parts of your Java application that are most heavily used.

When there is an obstacle, or when a Java based Web application is running much slower than expected, we need to use thread dumps. 

Thread contention is a status in which one thread is waiting for a lock, held by another thread, to be lifted. Different threads frequently access shared resources on a web application. For example, to record a log, the thread trying to record the log must obtain a lock and access the shared resources.

Deadlock is a special type of thread contention, in which two or more threads are waiting for the other threads to complete their tasks in order to complete their own tasks.

Different issues can arise from thread contention. To analyze such issues, you need to use the thread dump. A thread dump will give you the information on the exact status of each thread.

To summarize, Thread dumps are essential diagnosis information used to analyze and troubleshoot performance related issues such as server hangs, deadlocks, slow running, idle or stuck applications, slow database interactions etc.

How to take thread dump?
1. Using Jstack (since 1.5): 
- Command line tool that comes with JDK.
- Get PID using jps -v
- Run "jstack -l  <pid> > <file-path>"

2. Using JVisualVM (since 1.6 update 7):
GUI Tool. Part of JDK - bin\jvisualvm.exe. This tool also has the capability to capture thread dumps from the java processes that are running in remote host as well.

a. Launch the jvisualvm. 
b. On the left panel, you will notice all the java applications that are running on your machine. Select one whose thread dump you want.
c. Go to the “Threads” tab. Click on the “Thread Dump” button.

3. Using kill -3:
In major enterprises for security reasons only JREs are installed in production machines. JDK tools to take thread dumps are not useful in such cases.

- Obtain the process pid by using ps -ef command to check the pid of the currently running Java process.
- Use the extracted pid as the parameter of "kill -3 <pid>" to obtain a thread dump.

When ‘kill -3’ option is used thread dump is sent to standard error stream. If you are running your application in tomcat, thread dump will be sent in to <TOMCAT_HOME>/logs/catalina.out file.

4. Java Mission Control (JMC) (since JDK 7 Update 40): 
Once you launch the tool, you will see all the Java processes that are running on your local or remote host.
On the left panel click on the “Flight Recorder” option that is listed below the Java process for which you want to take thread dumps. Here in the “Thread Dump” field, you can select the interval (like Every 60s) in which you want to capture thread dump. After the selection is complete start the Flight recorder. Once recording is complete, you will see the thread dumps in the “Threads” panel.

5. Windows (Ctrl + Break):
Will work only in Windows Operating system.

Select command line console window in which you have launched application.
Now on the console window issue the “Ctrl + Break” command.

The thread dump will be printed on the console window itself. To log to a perticular file, launch app as below:

java -classpath . SampleThreadProgram > C:\workspace\threadDump.txt 2>&1

Thus when you issue “Ctrl + Break” thread dump will be sent to C:\workspace\threadDump.txt file.

6. ThreadMXBean (since 1.5):
Interface to use for programmatical thread dump generation.

7. JCMD (Since 1.7):
JCMD Tool has various capabilities such as identifying java process Ids, acquiring heap dumps, acquiring thread dumps, acquiring garbage collection statistics etc.

jcmd <pid> Thread.print > <file-path>

Ex. jcmd 37320 Thread.print > /opt/tmp/threadDump.txt

Jstack & kill -3 are the best options because of Simpleness and Universalness (work with most of the versions).

Vs Head Dump:
A Heap Dump is a snapshot of the Java process heap memory at a given time. It's a useful tool to troubleshoot memory leaks and other memory related issues. Heap dumps are to memory what thread dumps are to java threads.

Using WebLogic Server:
a. From the WLS Administration Console, a thread dump can be created by navigating to Servers -> <Server Name> -> Monitoring -> Threads -> Dump Threads Stack OR Servers -> <Server Name> -> Monitoring -> Performance > Dump Threads Stack. These methods could lead to truncated or incomplete thread dumps.
You can force garbage collecting through Servers -> <Server Name> -> Monitoring -> Performance > Garbage Collect.
b. Using WLST script with threadDump() command.
c. Using T3ServicesDef
Can collect The Thread Dump remotely. This can be achieved using “weblogic.common.T3ServicesDef” and “weblogic.common.AdminServicesDef”  weblogic APIs. To achieve it, we need to simply run “. ./setWLSEnv.sh” and run a program (search for it on web http://middlewaremagic.com/weblogic/?p=1379).
d. Using “weblogic.Admin” which is deprecated but still available:
Ex. java weblogic.Admin -url t3://AdminHostName:7001 -username weblogic -password weblogic THREAD_DUMP
Thread Dumps will be generated in the Servers STDOUT file. Make sure you export weblogic.jar in your path.
e. Invoke WebLogic.WLST: 
java weblogic.WLST connect("weblogic","weblogic","t3:<weblogicinstaceaddress>:<port>") threadDump()
Make sure you export weblogic.jar in your path.
-------------------------------------
Covarient return type?
=> returning own Class reference or its child class reference.

- The covariant return type in java, allows narrowing down return type of the OVERRIDDEN method.
- The covariant return type always works only for non-primitive return types.

It was not possible override any method by changing the return type before Java 1.5 version. The only limitation is child’s return type should be sub-type of parent’s return type (non-primitive type only).

Advantages:
- It helps to avoid confusing type casts present in the class hierarchy and thus making the code readable, usable and maintainable.
- We get a liberty to have more specific return types when overriding methods.
- Help in preventing run-time ClassCastExceptions on returns.

Ex:
class A{  
	A get(){return this;}  
}  
  
class B1 extends A{  
	B1 get(){return this;}  
	void message(){System.out.println("welcome to covariant return type");}  
  
	public static void main(String args[]){  
		new B1().get().message();  
	}  
}  

Both methods (message in parent & child) have different return types but it is method overriding. It is possible because of covariant return type.
-------------------------------------
Static var/method in inheritance?
- Child can access directly the Static var/method from Parent class if it's not defined with private access specifier.
- You can use Parent Class Name or Child class name object to use it, however a WARNING will be shown that the it "should be accessed in a static way".
-------------------------------------
How to count no of threads?
1. There is a static method on the Thread Class that will return the number of active threads controlled by the JVM:
	Thread.activeCount()
	Returns the number of active threads in the current thread's thread group.

2. ManagementFactory.getThreadMXBean().getThreadCount() doesn't limit itself to thread groups as Thread.activeCount() does.

3. Additionally, external debuggers should list all active threads (and allow you to suspend any number of them) if you wish to monitor them in real-time.

	Useful tool for debugging java programs, it gives the number of threads and other relevant info on them:
	jconsole <process-id>
	
	jconsole and jvisualvm are the 

4. This will give you the total number of threads in your VM :

	int nbThreads =  Thread.getAllStackTraces().keySet().size();

	Now, if you want all threads currently executing, you can do that :

	int nbRunning = 0;
	for (Thread t : Thread.getAllStackTraces().keySet()) {
		if (t.getState()==Thread.State.RUNNABLE) nbRunning++;
	}
-------------------------------------
Abstraction vs Encapsulation

1. Abstraction focuses on the outside view of an object (i.e. the interface) Encapsulation (information hiding) prevents clients from seeing it’s inside view, where the behavior of the abstraction is implemented.

2. Abstraction solves the problem in the design side while Encapsulation is the Implementation.

3. Abstraction lets you focus on what the object does instead of how it does it. Encapsulation means hiding the code and data into a single unit to protect the data from outside world.

4. The part that is hidden relates to encapsulation while the part that is exposed relates to abstraction.

5. In abstraction we hide something to reduce the complexity of it (implementation hiding) and In encapsulation we hide something to protect the data (info hiding).
-------------------------------------
Abstraction
Abstraction is the concept of hiding the internal details and describing things in simple terms. For example, a method that adds two integers. The method internal processing is hidden from outer world. There are many ways to achieve abstraction in object oriented programming, such as encapsulation and inheritance.

A java program is also a great example of abstraction. Here java takes care of converting simple statements to machine language and hides the inner implementation details from outer world. You can use abstraction using Interface and Abstract class in Java.

=> abstraction is getting interested from reality .
=> Implementation hiding.

Encapsulation
Encapsulation is the technique used to implement abstraction in object oriented programming. Encapsulation is used for access restriction to a class members and methods.

=> wrapping of data and methods in single entity referred as class.
=> Information Hiding.

Access modifier keywords are used for encapsulation in object oriented programming. For example, encapsulation in java is achieved using private, protected and public keywords.

Polymorphism
Polymorphism is the concept where an object behaves differently in different situations. There are two types of polymorphism – compile time polymorphism and runtime polymorphism. Compile time polymorphism is achieved by method overloading. 

Method overloading - methods' name is same but arguments are different. Here compiler will be able to identify the method to invoke at compile time, hence it’s called compile time polymorphism.

Runtime polymorphism is implemented when we have “IS-A” relationship between objects. This is also called as method overriding because subclass has to override the superclass method for runtime polymorphism. Compiler is not able to decide which class method will be invoked. This decision is done at runtime, hence the name as runtime polymorphism or dynamic method dispatch.

Inheritance
Inheritance is the object oriented programming concept where an object is based on another object. Inheritance is the mechanism of code reuse. The object that is getting inherited is called superclass and the object that inherits the superclass is called subclass.

We use extends keyword in java to implement inheritance. 

Association
Association is the OOPS concept to define the RELATIONSHIP between objects. Association defines the multiplicity between objects. For example Teacher and Student objects. There is one to many relationship between a teacher and students. Similarly a student can have one to many relationship with teacher objects. However both student and teacher objects are independent of each other.

Aggregation
Aggregation is a special type of association. In aggregation, objects have their own life cycle but there is an ownership. Whenever we have “HAS-A” relationship between objects and ownership then it’s a case of aggregation. Ex: Employee has an Address.

Composition
Composition is a special case of aggregation. Composition is a more restrictive form of aggregation. When the contained object in “HAS-A” relationship can’t exist on it’s own, then it’s a case of composition. For example, House has-a Room. Here room can’t exist without house.
-------------------------------------
Java Heap Space

Java Heap space is used by java runtime to allocate memory to Objects and JRE classes. Whenever we create any object, it’s always created in the Heap space.

Garbage Collection runs on the heap memory to free the memory used by objects that doesn’t have any reference. Any object created in the heap space has global access and can be referenced from anywhere of the application.

Java Stack Memory

Java Stack memory is used for execution of a thread. They contain method specific values that are short-lived and references to other objects in the heap that are getting referred from the method.

Stack memory is always referenced in LIFO (Last-In-First-Out) order. Whenever a method is invoked, a new block is created in the stack memory for the method to hold local primitive values and reference to other objects in the method.

As soon as method ends, the block becomes unused and become available for next method. Stack memory size is very less compared to Heap memory.

Heap and Stack Memory in Java Program

Let’s understand the Heap and Stack memory usage with a simple program.
public class Memory {

	public static void main(String[] args) { // Line 1
		int i=1; // Line 2
		Object obj = new Object(); // Line 3
		Memory mem = new Memory(); // Line 4
		mem.foo(obj); // Line 5
	} // Line 9

	private void foo(Object param) { // Line 6
		String str = param.toString(); //// Line 7
		System.out.println(str);
	} // Line 8
}

Let’s go through the steps of execution of the program.

- As soon as we run the program, it loads all the Runtime classes into the Heap space. When main() method is found at line 1, Java Runtime creates stack memory to be used by main() method thread.
- We are creating primitive local variable at line 2, so it’s created and stored in the stack memory of main() method.
- Since we are creating an Object in line 3, it’s created in Heap memory and stack memory contains the reference for it. Similar process occurs when we create Memory object in line 4.
- Now when we call foo() method in line 5, a block in the top of the stack is created to be used by foo() method. Since Java is pass by value, a new reference to Object is created in the foo() stack block in line 6.
- A string is created in line 7, it goes in the String Pool in the heap space and a reference is created in the foo() stack space for it.
- foo() method is terminated in line 8, at this time memory block allocated for foo() in stack becomes free.
- In line 9, main() method terminates and the stack memory created for main() method is destroyed. Also the program ends at this line, hence Java Runtime frees all the memory and end the execution of the program.

Difference between Java Heap Space and Stack Memory
1. Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.
2. Whenever an object is created, it’s always stored in the Heap space and stack memory contains the reference to it. Stack memory only contains local primitive variables and reference variables to objects in heap space.
3. Objects stored in the heap are globally accessible whereas stack memory can’t be accessed by other threads.
4. Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. 
5. Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.
6. We can use -Xms and -Xmx JVM option to define the startup size and maximum size of heap memory. We can use -Xss to define the stack memory size.
7. When stack memory is full, Java runtime throws java.lang.StackOverFlowError whereas if heap memory is full, it throws java.lang.OutOfMemoryError: Java Heap Space error.
8. Stack memory size is very less when compared to Heap memory. Because of simplicity in memory allocation (LIFO), stack memory is very fast when compared to heap memory.
9. Where is it stored? Variables that are allocated on the stack are accessible directly from memory, and as such, these can run very fast. Accessing objects on the heap, on the other hand, takes more time.
10. When does the allocation happen? On the stack, memory allocation happens when the program is compiled. Meanwhile, on the heap, it begins when the program is run.
-------------------------------------
ArrayList vs HashMap in Java

A Map is a map, or "associative array". It has a key->value layout. A List is on the other hand a list, which is an ordered collection of elements.

1) Implementation: ArrayList implements List Interface while HashMap is an implementation of Map interface. 

2) Memory consumption: ArrayList stores the element’s value alone and internally maintains the indexes for each element.

	 ArrayList<String> arraylist = new ArrayList<String>();
	//String value is stored in array list
	 arraylist.add("Test String");
	 
HashMap stores key & value pair. For each value there must be a key associated in HashMap. That clearly shows that memory consumption is high in HashMap compared to the ArrayList.

	HashMap<Integer, String> hmap= new HashMap<Integer, String>();
	//String value stored along with the key value in hash map
	 hmap.put(123, "Test String");
	 
3) Order: ArrayList maintains the insertion order while HashMap doesn’t. Which means ArrayList returns the list items in the same order in which they got inserted into the list. 

4) Duplicates: ArrayList allows duplicate elements but HashMap doesn’t allow duplicate keys (It does allow duplicate values).

5) Nulls: ArrayList can have any number of null elements. HashMap allows one null key and any number of null values.

6) get method: In ArrayList we can get the element by specifying the index of it. In HashMap, the elements is being fetched by specifying the corresponding key.

7) Keys of HashMap must implements equals and hashCode method correctly, ArrayList doesn't have that requirement but its good to have that because contains()  method of ArrayList will use equals() method to see if that object already exists or not.

When you need a structure from which you will be retrieving items randomly - use a HashMap.
When you will be retrieving items in order (e.g. using a for loop) - use an ArrayList

There's also a combined data structure, the LinkedHashMap, which offers fast access to arbitrary elements as well as predictable ordering.

Similarity between ArrayList and HashMap in Java

1) BothArrayList and HashMap are not synchronized, you should not use them in the multi-threading environment without external  synchronization.

2) Both ArrayList and HashMap Iterator are fail-fast, they will throw ConcurrentModificationException as soon as they detect any structural change in ArrayList or HashMap once Iterator is created.

3) Both ArrayList and HashMap allows null. 

4) Both ArrayList and HashMap allows duplicate elements.

5) ArrayList is backed by array similarly, HashMap is also internally implemented by Array.

6) Both ArrayList and HashMap can be traversed through Iterator in Java.

Practical Example:
Employee objects are stored using HashMap. How to use ArrayList for storing Employee objects?

List empList = ArrayList<Employee>;

Employee id can be the index of the list.
-------------------------------------
ArrayList Vs LinkedList

1) Search: ArrayList search operation is pretty fast compared to the LinkedList search operation. get(int index) in ArrayList gives the performance of O(1) while LinkedList performance is O(n).

Reason: ArrayList maintains index based system for its elements as it uses array data structure implicitly which makes it faster for searching an element in the list. On the other side LinkedList implements doubly linked list which requires the traversal through all the elements for searching an element.

2) Deletion: LinkedList remove operation gives O(1) performance while ArrayList gives variable performance: O(n) in worst case (while removing first element) and O(1) in best case (While removing last element).

Conclusion: LinkedList element deletion is faster compared to ArrayList.

Reason: LinkedList’s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. While In ArrayList, all the elements need to be shifted to fill out the space created by removed element.

3) Inserts Performance: LinkedList add method gives O(1) performance while ArrayList gives O(n) in worst case. Reason is same as explained for remove.

4) Memory Overhead: ArrayList maintains indexes & element data whereas LinkedList maintains element data and two pointers for neighbor nodes hence the memory consumption is high in LinkedList comparatively.

There are few similarities between these classes which are as follows:

- Both ArrayList and LinkedList are implementation of List interface.
- They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements the result set would be having the same order in which the elements got inserted into the List.
- Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.
- The iterator and listIterator returned by these classes are fail-fast (if list is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove or add methods, the iterator will throw a ConcurrentModificationException).

When to use LinkedList and when to use ArrayList?
1) As explained above the insert and remove operations give good performance [O(1)] in LinkedList compared to ArrayList[O(n)]. Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.

2) Search (get method) operations are fast in Arraylist [O(1)] but not in LinkedList [O(n)] so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.
-------------------------------------
ArrayList and Vector
ArrayList and Vector both implements List interface and maintains insertion order.

They both use Array as a data structure internally. However there are few differences in the way they store and process the data. 

1) Synchronization: ArrayList is non-synchronized which means multiple threads can work on ArrayList at the same time.

Vector is synchronized. This means if one thread is working on Vector, no other thread can get a hold of it. Unlike ArrayList, only one thread can perform an operation on vector at a time.

2) Resize: Both ArrayList and Vector can grow and shrink dynamically to maintain the optimal use of storage, however the way they resized is different. ArrayList grow by half of its size when resized while Vector doubles the size of itself by default when grows.

3) Performance: ArrayList gives better performance as it is non-synchronized. Vector operations gives poor performance as they are thread-safe, the thread which works on Vector gets a lock on it which makes other thread wait till the lock is released.

4) fail-fast: What is fail-fast => If the collection (ArrayList, vector etc) gets structurally modified by any means, except the add or remove methods of iterator, after creation of iterator then the iterator will throw ConcurrentModificationException. Structural modification refers to the addition or deletion of elements from the collection.

As per the Vector javadoc the Enumeration returned by Vector is NOT fail-fast. On the other side the iterator and listIterator returned by ArrayList are fail-fast.

5) Who belongs to collection framework really? The vector was NOT the part of collection framework, it has been included in collections later. It can be considered as Legacy code. There is nothing about Vector which List collection cannot do. Therefore Vector should be avoided. If there is a need of thread-safe operation make ArrayList synchronized or use CopyOnWriteArrayList which is a thread-safe variant of ArrayList.

There are few similarities between these classes which are as follows:
- Both Vector and ArrayList use growable array data structure.
- The iterator and listIterator returned by these classes (Vector and ArrayList) are fail-fast.
- They both are ordered collection classes as they maintain the elements insertion order.
- Vector & ArrayList both allows duplicate and null values.
- They both grows and shrinks automatically when overflow and deletion happens.

When to use ArrayList and when to use vector?

It totally depends on the requirement. If there is a need to perform “thread-safe” operation the vector is your best bet as it ensures that only one thread access the collection at a time.

Performance: Synchronized operations consumes more time compared to non-synchronized ones so if there is no need for thread safe operation, ArrayList is a better choice as performance will be improved because of the concurrent processes.
-------------------------------------
How to make ArrayList synchronized?
As I stated above ArrayList methods are non-synchronized but still if there is a need you can make them synchronized like this –

//Use Collecions.synzhonizedList method
List list = Collections.synchronizedList(new ArrayList());
...

//If you wanna use iterator on the synchronized list, use it
//like this. It should be in synchronized block.
synchronized (list) {
  Iterator iterator = list.iterator();
  while (iterator.hasNext())
      ...
      iterator.next();
      ...
}
-------------------------------------
How to sort Hashtable in java
Hashtable doesn’t preserve the insertion order, neither it sorts the inserted data based on keys or values. Which means no matter what keys & values you insert into Hashtable, the result would not be in any particular order.

The are ways to sort Hashtable using Collections.list and Collections.sort, however best thing to do is use LinkedHashMap or TreeMap.

Use LinkedHashMap: When you want to preserve the insertion order.
Use TreeMap: When you want to sort the key-value pairs.

      TreeMap<Integer, String> tm= new TreeMap<Integer, String>();
      tm.put(10, "Chaitanya");
      tm.put(1, "Ajeet");
      tm.put(11, "Test");
      // Get a set of the entries
      Set set = tm.entrySet();
      // Get an iterator
      Iterator i = set.iterator();
      // Display elements
      while(i.hasNext()) {
        Map.Entry me = (Map.Entry)i.next();
        System.out.print(me.getKey() + ": ");
        System.out.println(me.getValue());
      }
-------------------------------------
HashMap vs Hashtable

1) HashMap is non-synchronized. This means if it’s used in multithread environment then more than one thread can access and process the HashMap simultaneously.

Hashtable is synchronized. It ensures that no more than one thread can access the Hashtable at a given moment of time. The thread which works on Hashtable acquires a lock on it to make the other threads wait till its work gets completed.

2) HashMap allows one null key and any number of null values.

Hashtable doesn’t allow null keys and null values.

3) HashMap implementation LinkedHashMap maintains the insertion order and TreeMap sorts the mappings based on the ascending order of keys.

Hashtable doesn’t guarantee any kind of order. It doesn’t maintain the mappings in any particular order.

4) Initially Hashtable was not the part of collection framework it has been made a collection framework member later after being retrofitted to implement the Map interface.

HashMap implements Map interface and is a part of collection framework since the beginning.

5) Another difference between these classes is that the Iterator of the HashMap is a fail-fast and it throws ConcurrentModificationException if any other Thread modifies the map structurally by adding or removing any element except iterator’s own remove() method. In Simple words fail-fast means: When calling iterator.next(), if any modification has been made between the moment the iterator was created and the moment next() is called, a ConcurrentModificationException is immediately thrown.

Enumerator for the Hashtable is not fail-fast.

When to use HashMap and Hashtable?

1) As stated above the main difference between HashMap & Hashtable is synchronization. If there is a need of thread-safe operation then Hashtable can be used as all its methods are synchronized but it’s a legacy class and should be avoided as there is nothing about it, which cannot be done by HashMap. For multi-thread environment I would recommend you to use ConcurrentHashMap (Almost similar to Hashtable) or even you can make the HashMap synchronized explicitly.

2) Synchronized operation gives poor performance so it should be avoided until unless required. Hence for non-thread environment HashMap should be used without any doubt.
-------------------------------------
Is Java pass-by-value or pass-by-reference?
Java is always pass-by-value. Unfortunately, they decided to call the location of an object a "reference". When we pass the value of an object, we are passing the reference to it. This is confusing to beginners.

The key to understanding this is that something like

Dog myDog;
is not a Dog; it's actually a pointer to a Dog.

What that means, is when you have

Dog myDog = new Dog("Rover");
foo(myDog);
you're essentially passing the address of the created Dog object to the foo method.

(I say essentially because Java pointers aren't direct addresses, but it's easiest to think of them that way)

Suppose the Dog object resides at memory address 42. This means we pass 42 to the method.

if the Method were defined as

public void foo(Dog someDog) {
    someDog.setName("Max");     // AAA
    someDog = new Dog("Fifi");  // BBB
    someDog.setName("Rowlf");   // CCC
}
let's look at what's happening.

the parameter someDog is set to the value 42
at line "AAA"
someDog is followed to the Dog it points to (the Dog object at address 42)
that Dog (the one at address 42) is asked to change his name to Max
at line "BBB"
a new Dog is created. Let's say he's at address 74
we assign the parameter someDog to 74
at line "CCC"
someDog is followed to the Dog it points to (the Dog object at address 74)
that Dog (the one at address 74) is asked to change his name to Rowlf
then, we return
Now let's think about what happens outside the method:

Did myDog change?

There's the key.

Keeping in mind that myDog is a pointer, and not an actual Dog, the answer is NO. myDog still has the value 42; it's still pointing to the original Dog (but note that because of line "AAA", its name is now "Max" - still the same Dog; myDog's value has not changed.)
-------------------------------------
Experience with Multithreading?
- Finetune the no of threads available for execution on WLS - to manage concurrent no of users. Normally, app server is well tested to handle multi-threading.
- Snippet of code marked with Synchronized block to take care of issues because multi-threading like use of Singleton DP while creating DB connection object.
- Otherwise Theoretical knowledge: You need that knowledge in understanding and debugging app issues related to concurrenct execution of threads.
-------------------------------------
What is URL rewriting?
URL manipulation, also called URL rewriting, is the process of altering (often automatically by means of a program written for that purpose) the parameters in a URL (Uniform Resource Locator). 

In URL rewriting, we append a token or identifier to the URL of the next Servlet or the next resource. We can send parameter name/value pairs using the following format:

url?name1=value1&name2=value2&??

When the user clicks the hyperlink, the parameter name/value pairs will be passed to the server. From a Servlet, we can use getParameter() method to obtain a parameter value.

Advantage of URL Rewriting

It will always work whether cookie is disabled or not (browser independent).
Extra form submission is not required on each pages.

Disadvantage of URL Rewriting

It will work only with links.
It can send Only textual information.
-------------------------------------
What is SQL Injection?
SQL injection is one of the most common web hacking techniques. It is the placement of malicious code in SQL statements, via web page input. It may also be used to destroy your database.

By leveraging an SQL Injection vulnerability, given the right circumstances, an attacker can use it to bypass a web application’s authentication and authorization mechanisms and retrieve the contents of an entire database. SQL Injection can also be used to add, modify and delete records in a database, affecting data integrity.

An SQL Injection needs just two conditions to exist – a relational database that uses SQL, and a user controllable input which is directly used in an SQL query.

Ex: SQL injection usually occurs when you ask a user for input, like their username/userid, and instead of a name/id, the user gives you an SQL statement that you will unknowingly run on your database.

UserId: 105 OR 1=1

Then, the SQL statement will look like this: SELECT * FROM Users WHERE UserId = 105 OR 1=1;
It will return ALL rows from the "Users" table, since OR 1=1 is always TRUE.

Another ex. 
User Name: " or ""="
Password: " or ""="

The code at the server will create a valid SQL statement like this:
SELECT * FROM Users WHERE Name ="" or ""="" AND Pass ="" or ""=""
The SQL above is valid and will return all rows from the "Users" table, since OR ""="" is always TRUE.

java.sql.Statement enforces SQL injection, because we end up using query formed using concatenated SQL strings in java JDBC.
java.sql.PreparedStatement prevents SQL injection, because text for all the parameter values is escaped in java JDBC.
-------------------------------------
JDBC PreparedStatement example – Batch Update

dbConnection.setAutoCommit(false);//commit trasaction manually

PreparedStatement = dbConnection.prepareStatement(insertTableSQL);

preparedStatement.setInt(1, 101);
.
.
preparedStatement.setTimestamp(4, getCurrentTimeStamp());
preparedStatement.addBatch();

preparedStatement.setInt(1, 102);
.
.
preparedStatement.setTimestamp(4, getCurrentTimeStamp());
preparedStatement.addBatch();

preparedStatement.executeBatch();
dbConnection.commit();

Batch Update is not limit to Insert statement, it’s apply for Update and Delete statement as well.

Alternatively, you can use normal executeUpdate() method. However, every executeUpdate() will hit database once. For batch update process, it hits database when executeBatch() is called.
-------------------------------------
java.sql.CallableStatement
The java.sql.CallableStatement is an interface which is used to execute SQL stored procedures, cursors and functions in java. 

java.sql.CallableStatement extends the PreparedStatement interface. 
 
As CallableStatement is sub interface of PreparedStatement it adds a level of abstraction, so the execution of stored procedure or functions need not to be dbms specific.

How to deal with SQL stored procedures IN parameter in java- 
 1) set methods are used for setting IN parameter values. (Must know : set methods are inherited from java.sql.PreparedStatement) 

How to deal with SQL stored procedures OUT parameter in java- 
 1) OUT parameters must be registered in java before executing the stored procedure, 
 2) Execute database stored procedure,
 3) Then retrieve values of OUT parameters using using get methods. 
 
How to deal with SQL stored procedures IN OUT parameter in java- 
 - Like IN parameters, set methods are used for setting IN OUT parameter values. 
 - Like OUT parameters, IN OUT parameters must be registered in java before executing the stored procedure, 
 - Execute database stored procedure, Then like OUT parameters, retrieve values of IN OUT parameters using using get methods. 
-------------------------------------
Statement object execute methods:

Once you've created a Statement object, you can then use it to execute an SQL statement with one of its three execute methods.

1. boolean execute (String SQL): Returns a boolean value of true if a ResultSet object can be retrieved; otherwise, it returns false. Use this method to execute SQL DDL statements or when you need to use truly dynamic SQL.

2. int executeUpdate (String SQL): Returns the number of rows affected by the execution of the SQL statement. Use this method to execute SQL statements for which you expect to get a number of rows affected - for example, an INSERT, UPDATE, or DELETE statement.

3. ResultSet executeQuery (String SQL): Returns a ResultSet object. Use this method when you expect to get a result set, as you would with a SELECT statement.

If you close the Connection object first, it will close the Statement object as well. However, you should always explicitly close the Statement object to ensure proper cleanup.
-------------------------------------
JDBC Driver:
JDBC Driver is a software component that enables java application to interact with the database.There are 4 types of JDBC drivers:

- Type 1, JDBC-ODBC Bridge plus ODBC Driver : JDBC-ODBC bridge driver uses ODBC driver to connect to the database. The JDBC-ODBC bridge driver converts JDBC method calls into the ODBC function calls. This is now discouraged because of thin driver.
	- Easy to use. Can be easily connected to any database.
	- Performance degraded because JDBC method call is converted into the ODBC function calls.
	- The ODBC driver needs to be installed on the client machine.
-  Type 2: A native API partly Java technology-enabled driver: The Native API driver uses the client-side libraries of the database. The driver converts JDBC method calls into native calls of the database API. 
	- Better in performance than type 1.
	- The Native driver & Vendor client library need to be installed on the each client machine.	
- Network Protocol driver, Type 3: Pure Java Driver for Database Middleware: The Network Protocol driver uses middleware (application server) that converts JDBC calls directly or indirectly into the vendor-specific database protocol. It is fully written in java.
	- No client side library is required. 
	- Network support is required on client machine.
	- Requires database-specific coding to be done in the middle tier.
- Thin driver, Type 4: Direct-to-Database Pure Java Driver: The thin driver converts JDBC calls directly into the vendor-specific database protocol. That is why it is known as thin driver. It is fully written in Java language.
	- Better performance than all other drivers.
	- No software is required at client side or server side.
	- Driver depends on Database.

In my project, we have used datasource in weblogic for getting DB connection. It internally uses Type 4 (Thin) driver.

For test automation & FTP/Email Framework, program uses type 4 (JDBC Thin) driver as well i.e. oracle.jdbc.OracleDriver or updated oracle.jdbc.driver.OracleDriver.
-------------------------------------
Unix experience?
I've 6+ years of experience working with Unix or Linux shell scripts. Various activities that I have done on Unix or Linux servers are:
	1. Installing softwares & verifying them (like Java, Maven, SonarQube etc.)
	2. File Management - disk full issue, file copy with SCP, SFTP etc.
	3. SSH Putty session mgmt - login to the server, switch users using sudo commands.
	4. Writing shell scripts for different cron jobs.
	5. Modifying cron jobs.
	6. Checking log files.
	7. Deploying war files on WLS; WL Server restart 
	8. Modifying files using VI editor
		Basic VI commands:
			:wq - quit with saving (write & quit)
			:q! - quit without saving; q - quit
			sh - invoke shell
			/<pattern>: search forward a string pattern in file; n - go to next occurrence; N - go to previous occurrence.
			?<pattern>: search backward a string pattern in file;
			dd - delete a line; nd - delete n characters.
			a - Append after; A - Append at end of line
			i, I - Insert before
			x - Delete after; X - Delete before
			:0<Return> or 1G - move cursor to first line in file
			:n<Return> or nG - move cursor to line n
			:$<Return> or G - move cursor to last line in file
			r - replace single character under cursor (no <Esc> needed)
			R - replace characters, starting with current cursor position, until <Esc> hit
			yy - copy (yank, cut) the current line into the buffer
			Nyy or yNy - copy (yank, cut) the next N lines, including the current line, into the buffer
			p - put (paste) the line(s) in the buffer into the text after the current line
			^g - provides the current line number, along with the total number of lines, in the file at the bottom of the screen
-------------------------------------
Design Patterns in Java:
A design pattern is a well described solution to a common software problem. Some of the benefits of using design patterns are:

- Design Patterns are already defined and provides industry standard approach to solve a recurring problem, so it saves time if we sensibly use the design pattern. 
- Using design patterns promotes reusability that leads to more robust and highly maintainable code. 
- It makes our code easy to understand and debug. 
- It leads to faster development. New members of team can understand it easily.

Java Design Patterns are divided into three categories – creational, structural, and behavioral design patterns
			
Creational Design Patterns
	Singleton Pattern
	Factory Pattern
	Abstract Factory Pattern
	Builder Pattern
	Prototype Pattern
Structural Design Patterns
	Adapter Pattern
	Composite Pattern
	Proxy Pattern
	Flyweight Pattern
	Facade Pattern
	Bridge Pattern
	Decorator Pattern
Behavioral Design Patterns
	Template Method Pattern
	Mediator Pattern
	Chain of Responsibility Pattern
	Observer Pattern
	Strategy Pattern
	Command Pattern
	State Pattern
	Visitor Pattern
	Interpreter Pattern
	Iterator Pattern
	Memento Pattern
J2EE Patterns
	These design patterns are specifically concerned with the presentation tier. These patterns are identified by Sun Java Center.

What all design patterns have you worked with:
I have worked with - 
	Singleton, Factory, Decorator, Iterator, MVC, Service Locator Pattern, Front Controller, Data Access Object Pattern
	
MVC is more of an architectural pattern, but not for complete application. MVC mostly relates to the UI / interaction layer of an application. MVC Pattern stands for Model-View-Controller Pattern. This pattern is used to separate application's concerns.
	- Model - Model represents an object or JAVA POJO carrying data. It can also have logic to update controller if its data changes.
	- View - View represents the visualization of the data that model contains.
	- Controller - Controller acts on both model and view. It controls the data flow into model object and updates the view whenever data changes. It keeps view and model separate.

The service locator design pattern is used when we want to locate various services using JNDI lookup. Considering high cost of looking up JNDI for a service, Service Locator pattern makes use of caching technique. For the first time a service is required, Service Locator looks up in JNDI and caches the service object. Further lookup or same service via Service Locator is done in its cache which improves the performance of application to great extent. Following are the entities of this type of design pattern.
	- Service - Actual Service which will process the request. Reference of such service is to be looked upon in JNDI server.
	- Context / Initial Context -JNDI Context, carries the reference to service used for lookup purpose.
	- Service Locator - Service Locator is a single point of contact to get services by JNDI lookup, caching the services.
	- Cache - Cache to store references of services to reuse them
	- Client - Client is the object who invokes the services via ServiceLocator. 
	
The front controller design pattern is used to provide a centralized request handling mechanism so that all requests will be handled by a single handler. This handler can do the authentication/ authorization/ logging or tracking of request and then pass the requests to corresponding handlers. Following are the entities of this type of design pattern.
	- Front Controller - Single handler for all kind of request coming to the application (either web based/ desktop based).
	- Dispatcher - Front Controller may use a dispatcher object which can dispatch the request to corresponding specific handler.
	- View - Views are the object for which the requests are made.

Data Access Object Pattern or DAO pattern is used to separate low level data accessing API or operations from high level business services. Following are the participants in Data Access Object Pattern.
	- Data Access Object Interface - This interface defines the standard operations to be performed on a model object(s).
	- Data Access Object concrete class -This class implements above interface. This class is responsible to get data from a datasource which can be database / xml or any other storage mechanism.
	- Model Object or Value Object - This object is simple POJO containing get/set methods to store data retrieved using DAO class.
	
-------------------------------------
Singleton Design Pattern:
Singleton pattern restricts the instantiation of a class and ensures that only one instance of the class exists in the java virtual machine. 

The singleton class must provide a global access point to get the instance of the class. Singleton pattern is used for logging, drivers objects, caching and thread pool.

There are many classes in JDK which is implemented using Singleton pattern like java.lang.Runtime which provides getRuntime() method to get access of it and used to get free memory and total memory in Java. Other Ex - Java.awt.Desktop with getDesktop(); Java.awt.Toolkit with getDefaultToolkit() etc. 

Another example is a utility classes like Popup in GUI application, if you want to show popup with message you can have one PopUp class on whole GUI application and anytime just get its instance, and call show() with message.

Java Singleton Pattern is one of the Gangs of Four Design patterns and comes in the Creational Design Pattern category. 

Ways to implement it:

1. With public static final field initialized during class loading (Eager Loading)
In eager initialization, the instance of Singleton Class is created at the time of class loading. But it has a drawback that instance is created even though client application might not be using it. Also, this method doesn’t provide any options for exception handling.

public class SingletonClass
{
    private static final SingletonClass instance = new SingletonClass();
	
    //private constructor to avoid client applications to use constructor
	private SingletonClass() {
    }

    public static SingletonClass getInstance() {
      return instance;
    }
}

2. Static block initialization
Static block initialization implementation is similar to eager initialization, except that instance of class is created in the static block that provides option for exception handling.

public class SingletonClass
{
    private static SingletonClass instance;
	
    //private constructor to avoid client applications to use constructor
	private SingletonClass() {
    }
	
	//static block initialization for exception handling
    static{
        try{
            instance = new SingletonClass();
        }catch(Exception e){
            throw new RuntimeException("Exception occured in creating singleton instance");
        }
    }
	 

    public static SingletonClass getInstance() {
      return instance;
    }
}

Again, it creates the instance even before it’s being used and that is not the best practice to use. 

3. By synchronizing getInstance() method (Lazy Loading)

Before 1.5:
static Singleton instance;

public static synchronized Singleton getInstance() {
  if (instance == null)
    instance == new Singleton();
  return instance;
}

This approach reduces the performance because of cost associated with the synchronized method.

After 1.5:
Changes to the memory model in 1.5 enabled the infamous Double-Checked Locking (DCL) idiom. With it, the synchronized block is used inside IF condition with an additional check to ensure that only one instance of singleton class is created. To implement DCL, you check a volatile field in the common path and only synchronize when necessary:

static volatile Singleton instance;

public static Singleton getInstance() {
  if (instance == null) {
    synchronized (Singleton.class) {
      if (instance == null)
        instance == new Singleton();
    }
  }
  return instance;
}

But volatile isn't that much faster than synchronized. Use #4 (Singleton holder pattern) instead.

Double checked locking should only be used when you have requirement for lazy initialization otherwise use Enum to implement singleton or simple static final variable.

4. Usign static nested class (Singleton holder pattern)
Initialization on Demand Holder (IODH) idiom requires very little code and has zero synchronization overhead (even faster than volatile). IODH utilizes lazy class initialization - JVM will not initialize instance until someone calls getInstance().

It is also called Bill Pugh Singleton Implementation. And it uses a inner static holder class. This is the most widely used approach for Singleton class as it doesn’t require synchronization.

public class Singleton {
	private Singleton() {}
	
	private static class SingletonHolder {
	  private static final Singleton INSTANCE = new Singleton();    
	}

	public static Singleton getInstance() {
	  return SingletonHolder.INSTANCE;
	}
}

5. Using Enums (since Java 1.5): 
A single-element enum type is the best way to implement a singleton. Java ensures that any enum value is instantiated only once in a Java program. Since Java Enum values are globally accessible, so is the singleton. 

public enum Singleton { 
    INSTANCE;
	
    public void myMethod(){  
    }
}
-------------------------------------
How do you prevent for creating another instance of Singleton during serialization?
You can prevent this by using readResolve() method, since during serialization readObject() is used to create instance and it return new instance every time. However, you can replace it with original Singleton instance by using readResolve().

Use Enum to create Singleton because serialization of enum is taken care by JVM and it guarantees single instance.
-------------------------------------
Static Vs Singleton class:

The essential difference is: The existence form of a singleton is an object, static is not. This conduced the following things:

Singleton can be extended. Static class cannot be extended.
Singleton creation may not be threadsafe if it isn't implemented properly. Static are thread-safe.
Singleton can be passed around as an object. Static cannot.
Singleton can be garbage collected. Static cannot.

Singleton Class is class of which only single instance can exists per classloader. No instance of this class exists. Only fields and methods can be directly accessed as constants or helper methods.

A static class is one that has only static methods, for which a better word would be "functions". The design style embodied in a static class is purely procedural.

Singleton, on the other hand, is a pattern specific to OO design. It is an instance of an object (with all the possibilities inherent in that, such as polymorphism), with a creation procedure that ensures that there is only ever one instance of that particular role over its entire lifetime.

"When to choose which one?". what are the advantages of singleton class over static class, these questions comes at the design stages.

Singleton: Usage: classes that serve as global configuration , ex: Trial version of software with one database connection, JDK Runtime classes instances per jvm.

When to go: 1.While developing your code,you think of forward compatibilty, like tomorrow when you need to convert this singleton class to normal class or allow subclassing. 2. You can provide lazy loading feature , when this singleton class is heavy.

static: Usage: classes that basically does conversions,utility functions. please check Math class.

When to go: helper classes, used by all the classes in your api development.
Disadvantage: classes are eagerly loaded.
-------------------------------------
Generics features
Generics allows a type or method to operate on objects of various types while providing compile-time type safety, making Java a fully statically typed language.

1. Generics are implemented using Type Erasure:
A class or an interface can be declared to define one or more type parameters and those type parameters should be provided at the time of object construction. Ex. - List<Long> list = new ArrayList<Long>();

If you try to add any other type of element to this list, it will give you compile time error.

Generics helps detect type related errors at compile time and makes your code safe.

Once this piece of code is compiled ,the type information is erased resulting into similar byte code as we would have got if the same piece of code was written using Java 1.4 and below. This results in binary compatibility between different versions of Java. So, a List or List<> are all represented at run-time by the same type, List.

2. Generics does not support sub-typing:
Ex. - List<Number> numbers = new ArrayList<Integer>(); // will not compile

This would have resulted in ClassCastException at runtime and type safety could not be achieved. 

3. You can't create Generic Arrays:
because arrays carry runtime type information about the type of elements. 

Arrays uses type information at runtime to check the type of the object it contains and will throw ArrayStoreException if the type does not match. With Generics, type information gets erased at run time and the array store check will succeed in cases where it should fail.

Ex. - 	T[] arr = new T[10];// this code will not compile
		List<Integer>[] array = new List<Integer>[10]; // does not compile

Arrays are covariant by default, where as Generics does not support covariance. 

If the generic arrays were allowed, then we could assign ints array to an object array because arrays are covariant. After that we could add a List of double to the obj array. We will expect that this will fail with ArrayStoreException because we are assigning List of double to an array of List of integers. But the JVM cannot detect type mismatch because the type information gets erased. Hence the array store check succeeds, although it should have failed.

4. Use of wildcards with extends or super to increase API flexibility
For example, the addAll method in the Collection interface
boolean addAll(Collection<? extends E> c)
=> can not only add collection of type E but also of subtype of E.

Other ex: if we create a List of Number then we can not only add List of number but we can also add List of Integer or any other subtype of Number.

public static <T> boolean addAll(Collection<? super T> c, T... elements) ;

In this method you are adding elements of type T to the collection c. super is used instead of extends because elements are added into the collection c whereas in the previous example of Collection interface addAll method elements were read from the collection . In the Effective Java book, Joshua Bloch calls this PECS . PECS stands for producer extends, consumer super. 

5. Use of Multiple Bounds
A type parameter can also have multiple bounds:
<T extends B1 & B2 & B3>

A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first. For example:
	Class A { /* ... */ }
	interface B { /* ... */ }
	interface C { /* ... */ }

class D <T extends A & B & C> { /* ... */ }
-------------------------------------
Database design:
DB Design - I wasn't involved with the one from scratch. But I've to understand the existing database design and modify on top of it for the additional functionality. You need to follow the existing practices (starting from nomenclature till the use of indexes, triggers or use of sequences, retrieval of records from db etc).

The DB side experience consists of following activities:
1. Writing new or modifying existing queries (simple to complicated).
2. Analyzing queries and finetuning as required with the help of DBAs.
3. Analyzing and modifying stored procedures, functions and packages.
4. Executing procedures, functions & queries using JDBC, JPA and Linux shell scripts.
5. Analyzing data from DB for tier 2 support issues.
-------------------------------------
Are you a quick learner
I think I am. 

I was asked to work on a POC for the client. Develop a microservices based app using open source technologies with a team of 2 more team members.

And we did finish 2 functions from the main site (involving CRUD operations with UI) in 1 and half month. In that process, we learned using MicroServices based architecture, Spring Boot, REST Web Service, AngularJS, Bootstrap, HTML5, CSS3 and JSON. We had a working site ready for the demo and Client was very happy with that work.
-------------------------------------
What is type erasure
Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming. To implement generics, the Java compiler applies type erasure to:

- Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.
- Insert type casts if necessary to preserve type safety.
- Generate bridge methods to preserve polymorphism in extended generic types.

Type erasure ensures that no new classes are created for parameterized types; consequently, generics incur no runtime overhead.
-------------------------------------
Understanding hashcode & equals method:
When it comes to working with collections, we should override the equals() and hashCode() methods properly in the classes of the elements being added to the collections. Otherwise we will get unexpected behaviors or undesired results.

The Object class (the super class of all classes in Java) defines two methods equals() and hashCode().

The equals()method is designed to compare two objects semantically (by comparing the data members of the class), whereas the == operator compares two objects technically (by comparing their references i.e. memory addresses).

The implementation of equals()method in the Object class compares references of two objects. That means we should override it in our classes for semantic comparison - like these JDK classes override equals method: String, Date, Integer, Double etc.

Ex: the List interface provides the contains(Object) method which can be used for checking if the specified object exists in the list. Behind the scene, the list invokes the equals()method on the search object to compare it with other objects in the collection.

The hashCode()method returns an integer value which is used to distribute elements in buckets of a hashtable-based collection.

The default implementation of hashCode() in the Object class returns an integer number which is the memory address of the object. We should override it in our own classes. Most classes in the JDK override hashCode()method for having their own version/implementation: String, Date, Integer, Double, etc. 

As hashtable-based collection locates an element by invoking its hashCode() and equals() methods, so we must obey this contract (rules/) with regard to the way we override these methods:
1. When the equals() method is overridden, the hashCode() method must be overridden as well.
2. If two objects are equal, their hash codes must be equal as well.
3. If two objects are not equal, there’s no constraint on their hash codes (their hash codes can be equal or not).
4. If two objects have identical hash codes, there’s no constraint on their equality (they can be equal or not).
5. If two objects have different hash codes, they must not be equal.

If we violate these rules, the collections will behave unexpectedly such as the objects cannot be found, or wrong objects are returned instead of the correct ones.
-------------------------------------
What project planning work did you do?

This one relates to the Project Mgmt related activities which are not related to the development. We had a quality professional team (QSG) allocated for auditing project mgmt related artifacts. I was working with other leads to prepare docs/metrics for auditing.

Docs like - PMR, Project Plan, Dashboard ppt (have project app details, technologies, work items, issues/risk mgmt, learnings etc.), SLA violation report (for the apps with Prod Support) and other quality indicator docs (with metrics like app availability, failure rate, defect density etc.).

PMR includes Monthly/Quarterly updates, Financial info (billing), Risk Mgmt, Delivery Metrics (Development, Supprot, Testing), Defect Prevention Activities, Continutity Plan review, SQA Metrics, CSAT/PSAT Metrics, ValueAdd, Learnings, App-wise Work Progress, SLA Details etc.

Defect Prevention Activities include analysing defects and specifying plan on how to correct them going ahead. Corrective action examples can be - peer review, checklist modification etc.

Following activities are carried out during DP 
•	Collect Defect Data along with Class and Sub-Class – Defects will be maintained in Spectrum/TIPS
•	Identify 20% of the classes causing 80% of the defects using Pareto analysis
•	The root causes for defect class / sub class.
•	Decide on the action plan to eliminate the root causes
•	Track the status of the implementation of action proposal
•	Track the percentage (%) reduction in identified defect areas.

Project Plan includes project overview, stakeholders/client info, org chart, h/w - s/w environment, tools used, escalation plan, resource plan, risk mgmt, project tracking, defect mgmt, CM, Continutity plan, Operational Process and SQA Plan.
-------------------------------------
Project Planning Overview:
Communication plan: whom to inform & the frequency, which medium. Periodic Communication/Reporting to project stakeholders (sponsors). Report Progress.

PM - like director of movie. Should distribute media.

Scope Mgmt Plan: one should have process in place to manage scope change effectively. No one can anticipate all the contingencies. Hence need to incorporate scope change.

Have provision for: 
 - Approval of plans
 - Gap Analysis should be done.
 - Work Breakdown Structure (WBS)
	The WBS is a breakdown/ decomposition of project work into distinct work items at higher level. These work items are aligned with the project objective and can help the project team to create expected deliverables.
 - Budget & Resource assignment (Estimation)
 - Identify critical Path.

Risk in projects is the likelihood of the project's failure. During the project planning phase, risk must be analysed and a plan must be constructed to deal with risks in the event that they become actualized. 

Careful & detailed planning help us to reduces risk and in turn uncertainty in any given project. In meticulously planned project, project planner attempts to make a provision for potential occurrences of uncertainties in advance.

Project Scope Planning:
Any project is expected to provide its stakeholders with certain outcome, which is commonly termed as project deliverables. These project deliverables depends on the scope of the project. 

More detailing & precision during project planning definitely help the team organize their work efficiently & deliver the project more effectively. Without a project scope, project execution can go haywire. 

Project Deliverables
To define project scope, one needs to refer project requirements. The project planner needs to list down project deliverable items unambiguously stating whether they are ‘In Scope’ or ‘Not in Scope’. So, project scope is about outlining the project deliverables. Based on project scope, project planner(s)
create(s) work break down structure (WBS). 
-----------------------------
What work have you done for DevOps?
I used tools like Jenkins to faciliate implementation of DevOps practices in the team. 

With Jenkins, we created jenkins job to implement CI, CT & CD for different apps under our Project. I personally have created the first such job for the team to follow guidelines of. High level steps involved for CI are:

> Select “Build a free-style software project".
> Source Code Management section - configure SVN properties
> Build Triggers section - choose Build Periodically 
> Build section, click “Add build step” and select “Invoke Maven 3” (You may require configuring Maven 3 on Jenkins instance if one is already not configured - Jenkins > Manage Jenkins > Global Tool Configuration > Maven Installations > Add Maven)
mvn clean org.jacoco:jacoco-maven-plugin:prepare-agent install -Dmaven.test.failure.ignore=true -Pcoverage-per-test
-P implies profile added in maven pom file.
> Build section, click “Add build step” button and select “Invoke Standalone Sonar Analysis” (You may require installing SonarQube Scanner if one is not already installed - Jenkins > Manage Jenkins > Configure System > Add SonarQube).
> Verify Weblogic Deployer Plugin is installed on Jenkins instance. If not, get it from https://wiki.jenkins-ci.org/display/JENKINS/WebLogic+Deployer+Plugin
> Configure Weblogic Deployer Plugin on Jenkins > Manage Jenkins > Configure System. In case weblogic server is not installed on Jenkins instance, generate the wlfullclient.jar and add it on weblogic library path. Provide xml file path containing deployments targets.
NOTE: You can add jar and config file to SVN code first and then run partially the build job to get the code to the Jenkins job workspace.
> Add post-build action “Deploy the artifact to any Weblogic environments”
> Observe “WebLogic Deployments” log on build history.
-----------------------------
What is DevOps?
DevOps is a culture which promotes collaboration between Development and Operations Team to deploy code to production faster in an automated & repeatable way. The word 'DevOps' is a combination of two words 'development' and 'operations.'

DevOps helps to increases an organization's speed to deliver applications and services. It allows organizations to serve their customers better and compete more strongly in the market.

In simple words, DevOps can be defined as an alignment of development and IT operations with better communication and collaboration.

Why is DevOps is Needed?
- Before DevOps, the development and operation team worked in complete isolation.
- Testing and Deployment were isolated activities done after design-build. Hence they consumed more time than actual build cycles.
- Without using DevOps, team members are spending a large amount of their time in testing, deploying, and designing instead of building the project.
- Manual code deployment leads to human errors in production
- Coding & operation teams have their separate timelines and are not in synch causing further delays.

There is a demand to increase the rate of software delivery by business stakeholders.
-----------------------------
When to adopt DevOps?

DevOps should be used for large distributed applications such as eCommerce sites or applications hosted on a cloud platform.

When not to adopt DevOps?

It should not be used in a mission-critical application like bank, power and other sensitive data sites. Such applications need strict access controls on the production environment, a detailed change management policy, access control policy to the data centers.
-----------------------------
How is DevOps different from Agile? DevOps Vs Agile?
Stakeholders and communication chain a typical IT process:
 - Customer + SW Requirement
 - Developer + Tester
 - IT Infra + Operations

Agile addresses gaps in Customer and Developer communications. DevOps addresses gaps in Developer and IT Operations communications.

Agile: Focuses more on functional and non-functional readiness.
DevOps: focuses operational and business readiness.
------------------------------
DevOps Principles
Here, are six principles which are essential when adopting DevOps:

1. Customer-Centric Action: DevOps team must take customer-centric action for that they should constantly invest in products and services.

2. End-To-End Responsibility: The DevOps team need to provide performance support until they become end-of-life. This enhances the level of responsibility and the quality of the products engineered.

3. Continuous Improvement: DevOps culture focuses on continuous improvement to minimize waste. It continuously speeds up the improvement of product or services offered.

4. Automate everything: Automation is a vital principle of DevOps process. This is not only for the software development but also for the entire infrastructure landscape.

5. Work as one team: In the DevOps culture role of the designer, developer, and tester are already defined. All they needed to do is work as one team with complete collaboration.

6. Monitor and test everything: It is very important for DevOps team to have a robust monitoring and testing procedures.
------------------------------
Why change in company
I have been working with TechM for long time. I had been worked for the major clients of TechM. Now, I want to experience work culture of other company. With that I think I can improve myself. Working with different groups, clients & companies will certainly enrich my work experience - different problems to face, variety of new challenges, change in work dynamics etc.
--------------------------------------
Difference Between Hibernate get() and load() Methods ?
Few Points About Hibernate get() & load()
- Both are from Session interface, and we will call them as session.get() & session.load()
- Both will be use for retrieving the object (a row) from the database

The load() method is older; get() was added to Hibernate’s API later.

load():
When you call session.load() method, it will always return a “proxy” object.

Proxy means, hibernate will prepare some fake object with given identifier value in the memory without hitting the database, for example if we call session.load(Student.class,new Integer(107));  > hibernate will create one fake Student object [row] in the memory with id 107, but remaining properties of Student class will not even be initialized.

It will hit the database only when we try to retrieve the other properties of Student object i mean stdName, stdCountry. If object [row] not found in the database it will throws ObjectNotFoundException.

If load() can’t find the object in the cache or database, an exception is thrown. The load() method never returns null.

Since it returns a proxy object of requested entity, we can use it for lazy initialization purpose where we need only a reference of an object and no other its properties. It actually saves DB hits.

From performance point of view, load() method is recommended when compared to get() method.

get():
When you call session.get() method, it will hit the database immediately and returns the original object (with total info). If the row is not available in the database, it returns null. Any subsequent calls on the same session will return the object from the cache only.

We should go with this method when we want to make sure the required object i.e. data is present in the DB.
--------------------------------------
which version of hibernate you have used?
I have used Hibernate 3 in my previous assignments. But for programming practice, I've used the latest i.e. Hibernate 5 (Java 8 and JPA 2.1 Compatible).
JPA 1.0: Hibernate 3.2+
JPA 2.0: Hibernate 3.5+
JPA 2.1: Hibernate 4.3+
--------------------------------------
Differnce update() and merge() in Hibernate?

We call update() and merge() methods to transfer an object from detached state to persistent state.

A detached state object can be made persist by reattaching to a session. If previous session is closed then we can open a new session and we can reattach to a new session. To reattach we can use update() or merge() methods. Both are doing the same functionality, but there are few differences internally.

When we call update() method on session, if that session doesn’t contains same object (provided in update())  in cache then update() method successfully executed and the object been converted detached state to persistent state. If already a session cache containing the same object then the update() method throws an exception called NonUniqueObjectException.

If we call merge() method, then it verifies whether the same object is existed in the cache or not. If the object is existed in the cache then changes are copied in to the cache. other wise it will load the values to cache. Hence it doesn’t throw any exception.
--------------------------------------
Which action classes are used in struts 1
Apache Struts is an open source framework used to develop JSP or servlet based web application. Struts extend the Java servlet API and are based on the model view controller or MVC design pattern.

Action Class in Struts framework defines the business logic.

- Action class should extend org.apache.struts.action.Action class.
- Should override the execute method of the Action class.
- The org.apache.struts.action.ActionServlet selects the Action class for incoming http request defined under the action mapping tag in the struts-config.xml.
- These classes are used to invoke the classes at the business layer or data access layer to get the data from the bean and store the processed data and return the result or error depending upon the situation.
- Developer has to take care of the multithreaded impact as the action classes are not thread safe.

Struts has five different action classes of which the most commonly used are:
 - Action
 - DispatchAction

Others are IncludeAction, ForwardAction, LookupDispatchAction, and SwitchAction
 
Classes extending the org.apache.struts.actions.DispatchAction class have their own action forward methods. They can have multiple action forward methods thus becoming useful in case of multiple optional flows.

<action path = "/menuAction" type = "com.home.upload.action.MenuAction" name = "MenuForm" input = "/menu.jsp" parameter = "method" > 
	<forward name = "upload" path = "/fileUpload.jsp" /> 
	<forward name = "listFiles" path ="/listUploadedFiles.jsp" /> 
</action>
--------------------------------------
Which action classes are used in struts 2?

Actions are the core of the Struts2 framework, as they are for any MVC (Model View Controller) framework. Each URL is mapped to a specific action, which provides the processing logic which is necessary to service the request from the user.

Serves 2 imp purposes:
1. The action plays an important role in the transfer of data from the request through to the view, whether its a JSP or other type of result.
2. The action must assist the framework in determining which result should render the view that will be returned in the response to the request.

In struts 2, action class is POJO (Plain Old Java Object). POJO means you are not forced to implement any interface or extend any class. Generally, execute method should be specified that represents the business logic.

A convenient approach is to implement the com.opensymphony.xwork2.Action interface that defines 5 constants and one execute method. Action interface contains only one method execute that should be implemented overridden by the action class.

The only requirement for actions in Struts2 is that there must be one noargument method that returns either a String or Result object and must be a POJO. If the no-argument method is not specified, the default behavior is to use the execute() method.

Optionally you can extend the ActionSupport class which implements six interfaces including Action interface. It is a convenient class that implements many interfaces such as Action, Validateable, ValidationAware, TextProvider, LocaleProvider and Serializable . So it is mostly used instead of Action.

The Action interface is as follows −

public interface Action {
   public static final String SUCCESS = "success";
   public static final String NONE = "none";
   public static final String ERROR = "error";
   public static final String INPUT = "input";
   public static final String LOGIN = "login";
   public String execute() throws Exception;
}
--------------------------------------
Struts 2 Configuration File - extending struts-default package - what is the significance?

The struts application contains two main configuration files struts.xml file and struts.properties file.

The struts.properties file is used to override the default values of default.xml file provided by struts framework. So it is not mandatory.

struts.xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts  
Configuration 2.1//EN" "http://struts.apache.org/dtds/struts-2.1.dtd">  
<struts>  
	<package name="default" extends="struts-default">  
  		<action name="product" class="com.javatpoint.Product">  
		<result name="success">welcome.jsp</result>  
		</action>  
  	</package>  
</struts>      

We can easily divide our struts application into sub modules. The package element specifies a module. You can have one or more packages in the struts.xml file.

Attributes of package element:
	- name name is must for defining any package. 
	- namespace It is an optional attribute of package. If namespace is not present, / is assumed as the default namespace. In such case, to invoke the action class, you need this URI: /actionName.action  
	If you specify any namespace, you need this URI: /namespacename/actionName.action

extends The package element mostly extends the struts-default package where interceptors and result types are defined. If you extend struts-default, all the actions of this package can use the interceptors and result-types defined in the struts-default.xml file.

Action element: The action is the subelement of package and represents an action.

Attributes of action element: 
	- name name is must for defining any action.
	- class class is the optional attribute of action. If you omit the class attribute, ActionSupport will be considered as the default action. A simple action may be as:
		<action name="product">  
	- method It is an optional attribute. By default, execute method will be considered as the method of action class. So this code:
		<action name="product" class="com.javatpoint.Product">  
		will be same as:
		<action name="product" class="com.javatpoint.Product" method="execute">  
	If you want to invoke a particular method of the action, you need to use method attribute.

Result element: It is the sub element of action that specifies where to forward the request for this action.

Attributes of result element:
	- name is the optional attribute. If you omit the name attribute, success is assumed as the default result name.
	- type is the optional attribute. If you omit the type attribute, dispatcher is assumed as the default result type.
	
Other elements:
There are many other elements also such as global-exception-mappings, global-results, include etc. 
--------------------------------------
Explain MVC in struts

Model - Action class (pojo with execute method), ActionForm class.
View - JSP (result)
Controller - ActionServlet

The model contains the business logic and interact with the persistance storage to store, retrive and manipulate data.

The view is responsible for dispalying the results back to the user. In Struts the view layer is implemented using JSP.

The controller handles all the request from the user and selects the appropriate view to return. In Sruts the controller's job is done by the ActionServlet. 

The following events happen when the Client browser issues an HTTP request.

The ActionServlet receives the request.
	- The struts-config.xml file contains the details regarding the Actions, ActionForms, ActionMappings and ActionForwards.
	- During the startup the ActionServelet reads the struts-config.xml file and creates a database of configuration objects. Later while processing the request the ActionServlet makes decision by refering to this object.
	
When the ActionServlet receives the request it does the following tasks.
	- Bundles all the request values into a JavaBean class which extends Struts ActionForm class.
	- Decides which action class to invoke to process the request.
	- Validate the data entered by the user.
	- The action class process the request with the help of the model component. The model interacts with the database and process the request.
	- After completing the request processing the Action class returns an ActionForward to the controller.
	- Based on the ActionForward the controller will invoke the appropriate view.
	
The HTTP response is rendered back to the user by the view component.
--------------------------------------
Programming models - Model 1 vs Model 2(MVC)

Model 1 Architecture:
Servlet technology doesn't create process, rather it creates thread to handle request. The advantage of creating thread over process is that it doesn't allocate separate memory area. Problem in Servlet technology Servlet needs to recompile if any designing code is modified. It doesn't provide separation of concern. Presentation and Business logic are mixed up.

JSP overcomes almost all the problems of Servlet. It provides better separation of concern, now presentation and business logic can be easily separated. You don't need to redeploy the application if JSP page is modified. JSP provides support to develop web application using JavaBean, custom tags and JSTL so that we can put the business logic separate from our JSP that will be easier to test and debug.

- Browser sends request for the JSP page
- JSP accesses Java Bean and invokes business logic
- Java Bean connects to the database and get/save data
- Response is sent to the browser which is generated by JSP

+ Easy and Quick to develop web application
- Navigation control is decentralized - If JSP page name is changed that is referred by other pages, we need to change it in all the pages that leads to the maintenance problem.
- Time consuming You need to spend more time to develop custom tags in JSP (this is to avoid scriptlet).
- Hard to extend It is better for small applications but not for large applications.

Model 2 (MVC) Architecture:
Model 2 is based on the MVC (Model View Controller) design pattern. Model The model represents the state (data) and business logic of the application. View The view module is responsible to display data i.e. it represents the presentation. Controller The controller module acts as an interface between view and model. It intercepts all the requests i.e. receives input and commands to Model / View to change accordingly.

+ Navigation control is centralized Now only controller contains the logic to determine the next page.
+ Easy to maintain, extend, test
+ Better separation of concerns
- We need to write the controller code self. If we change the controller code, we need to recompile the class and redeploy the application.

The Struts framework provides the configurable MVC support.
--------------------------------------
Polymorphism example
Polymorphism in java is a concept by which we can perform a single action by different ways.

There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.

Runtime polymorphism or Dynamic Method Dispatch is a process in which a call to an overridden method is resolved at runtime rather than compile-time.

In this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.

Upcasting - When reference variable of Parent class refers to the object of Child class, it is known as upcasting. 
	class A{}  
	class B extends A{}  
	A a=new B();//upcasting  

Reverse process is downcasting. 

Dog d=(Dog)new Animal();  //Compiles successfully but ClassCastException is thrown at runtime  

static void method(Animal a) {  
    if(a instanceof Dog3){  
       Dog3 d=(Dog3)a;//downcasting  
       System.out.println("ok downcasting performed");  
    }
}	
	
static void method(Animal a) {  
       Dog4 d=(Dog4)a;//downcasting  
       System.out.println("ok downcasting performed");  
}  
	
Ex of runtime polymorphism: 
	Bank (Parent); SBI, ICICI, AXIS (Children) - float getRateOfInterest() is the overridden method.
	Shape(Parent); Circle, Triangle, Rectangle (Children); void draw() is the overridden method.
	Animal (Parent); Cat, Lion, Dog (Children) void eat() is the overridden method.

Why we cannot override static method? 
because static method is bound with class whereas instance method is bound with object. Main method also can't be overriden as it is also a static method.

Method Overloading: class has multiple methods having same name but different in parameters.

There are two ways to overload the method in java: By changing number of arguments, By changing the data type of the arguments.

In java, Method Overloading is not possible by changing the return type of the method only - java compiler renders compiler time error if you declare the same method having same parameters.

You can have any number of main methods in a class by method overloading. But JVM calls main() method which receives string array as arguments only.	
--------------------------------------
