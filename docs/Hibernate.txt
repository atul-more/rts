Draw Backs of JDBC:

> In JDBC, Programmer has to take care of DB Connection - creation, exception handling and closure.
> If Programmer didn’t close the connection in the finally block, then JDBC is not responsible to close that connection.
> If the table structure is modified then the JDBC program (original SQL Commands) doesn’t work.  Again we need to modify and compile and re-deploy required, which is tedious.
> JDBC generates database related error codes when exceptions are encountered; Java programmers are unaware of these error codes.
> In the Enterprise applications, the data flow with in an application from class to class will be in the form of objects, but while storing data finally in a database using JDBC then that object will be converted into text.  Because JDBC doesn’t transfer objects directly.

In order to overcome above problems,  Hibernate came into picture!

--------------------------
What is Hibernate?
Hibernate is the ORM tool given to transfer the data between a java (object) application and a database (Relational) in the form of the objects.  

It was started in 2001 by Gavin King as an alternative to EJB2 style entity bean.

Hibernate is a non-invasive framework meaning it won't force the programmers to extend/implement any class/interface. Because of use of POJO classes, Hibernate is light weight. It is purely for persistence (to store/retrieve data from Database).

The term Object/Relational Mapping refers to the technique of mapping data from an object model representation to a relational data model representation (and visa versa).

Hibernate not only takes care of the mapping from Java classes to database tables (and from Java data types to SQL data types), but also provides data query and retrieval facilities. It can significantly reduce development time otherwise spent with manual data handling in SQL and JDBC. Hibernate’s design goal is to relieve the developer from 95% of common data persistence-related programming tasks by eliminating the need for manual, hand-crafted data processing using SQL and JDBC. However, unlike many other persistence solutions, Hibernate does not hide the power of SQL from you and guarantees that your investment in relational technology and knowledge is as valid as always.

Hibernate may not be the best solution for data-centric applications that only use stored-procedures to implement the business logic in the database, it is most useful with object-oriented domain models and business logic in the Java-based middle-tier. 

--------------------------
Requirements:

Hibernate 5.2 and later versions require at least Java 1.8 and JDBC 4.2.

Hibernate 5.1 and older versions require at least Java 1.6 and JDBC 4.0.

--------------------------
Features/advantages of Hibernate:
JPA Provider - In addition to its own "native" API, Hibernate is also an implementation of the Java Persistence API (JPA) specification. As such, it can be easily used in any environment supporting JPA including Java SE applications, Java EE application servers, Enterprise OSGi containers, etc.

Idiomatic persistence - Hibernate enables you to develop persistent classes following natural Object-oriented idioms including inheritance, polymorphism, association, composition, and the Java collections framework. Hibernate requires no interfaces or base classes for persistent classes and enables any class or data structure to be persistent.

Support Performance - Hibernate supports lazy initialization, numerous fetching strategies and optimistic locking with automatic versioning and time stamping. Hibernate requires no special database tables or fields and generates much of the SQL at system initialization time instead of at runtime. Hibernate consistently offers superior performance over straight JDBC code, both in terms of developer productivity and runtime performance.

Scalable - Hibernate was designed to work in an application server cluster and deliver a highly scalable architecture. Hibernate scales well in any environment: Use it to drive your in-house Intranet that serves hundreds of users or for mission-critical applications that serve hundreds of thousands.

Reliable - Hibernate is well known for its excellent stability and quality, proven by the acceptance and use by tens of thousands of Java developers.

Extensibile - Hibernate is highly configurable and extensible

--------------------------
Persisting data to DB without hibernate:
	1. JDBC DB config - hostname, port, credentials etc.
	2. Define Model object to be stored.
	3. Service method to create/instantiate Model Object.
	4. Database Design for data storage.
	5. DAO method to save object using SQL query.
--------------------------
Persisting data to DB with hibernate:
	1. JDBC DB config - hibernate configuration (hibernate.cfg.xml)
	2. Define Model object to be stored - @Entity annotated class.
	3. Service method to create/instantiate Model Object - use Hibernate API
	Database Design for data storage - optional or not required (hibernate.hbm2ddl.auto property of hibernate configuration can take care of it).
	DAO method to save object using SQL query - not needed.
--------------------------
Service method to create/instantiate Model Object - use Hibernate API
	1. Create a "session factory" (one per app as is costlier operation - this step should use the default config file i.e. hibernate.cfg.xml file.): 
		SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
	2. Create a "session" from "session factory": 
		Session session = sessionFactory.openSession();
	3. Save model object using session:
		session.beginTransaction();
		session.save(userObject);
		session.getTransaction().commit();
		session.close();
	4. Create another session for a different opertation Ex. UserDetails userObject2 = (UserDetails)session.get(UserDetails.Class, 11186) and close it.
	5. Close sessionFactory.
--------------------------
Annotations:
@Entity annotate bean or pojo class. property name of the same can be used for the respective table name in DB. Resevered Keywords like user is not allowed for DB table name.

@Table annotate the pojo class to map to a table. property name of the same can be used to name the DB table. It won't change the default (class name) entity name (will be used in HQL query).

@Id & @Column annotations can be used with individual data members of the POJO class or with the getters to the same. Value to be stored in DB will be picked up using getter methods.

@Id => Primary Key.
Surrogate Key -> When a table is not having a column to be marked as primary key, Sr No key column (for example) can be added for making it as primary key.

Hibernate can generate value for Primary (Surrogate) Key using @GeneratedValue annotation along with @Id.

@GeneratedValue has property "strategy" with possible values of GenerationType enumeration - AUTO, IDENTITY (not with all DB), SEQUENCE (uses DB Sequence object), TABLE. Default is AUTO. Ex. @GeneratedValue (strategy=GenerationType.AUTO)

Hibernate maps java data types to db data types.
	String -> varchar(255)
	Int -> int
	Date -> date or timestamp
	
@Basic annotation for a data member tells hibernate that consider it as a data to be persisted. Default behavior is also the same.

@Transient annotation implies that the respective data member will be ignored for data persistence to DB. Static fields are also ignored.

@Temporal annotation is used to take a part of the date data type. It has property TemporalType enumeration to choose value from like TemporalType.DATE, TemporalType.TIME etc.

What if varchar(255) is not sufficient to store a column value?
use @Lob annotation. Maps to BLOB or CLOB data types depending on data contents.
--------------------------
What if a data member is an Object itself. Ex. Address of UserDetails class?
Address is "value object" inside UserDetails "Entity".

Approach 1: to have separate columns for address object members. Mark Address as @Embeddable to make it an object of Value type or use @Embedded annotation with Address member variable on UserDetails class.

However, 1 problem to address - what if 2 address data members are there - homeAddress & officeAddress. The corresponding insert will have duplicate name columns.
=> use @AttributeOverride annotation. properties name & column can be used to override column names of Address data memebers.
Ex.
@AttributeOverrides({
@AttributeOverride(name="street", column=@Column(name="home_street")),
@AttributeOverride(name="city", column=@Column(name="home_city")),
.
.
})
private Address homeAddress;

Approach 2: 